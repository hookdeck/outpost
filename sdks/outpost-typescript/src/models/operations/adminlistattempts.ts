/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Filter attempts by status.
 */
export const AdminListAttemptsStatus = {
  Success: "success",
  Failed: "failed",
} as const;
/**
 * Filter attempts by status.
 */
export type AdminListAttemptsStatus = ClosedEnum<
  typeof AdminListAttemptsStatus
>;

/**
 * Filter attempts by event topic(s). Can be specified multiple times or comma-separated.
 */
export type AdminListAttemptsTopic = string | Array<string>;

/**
 * Fields to include in the response. Can be specified multiple times or comma-separated.
 *
 * @remarks
 * - `event`: Include event summary (id, topic, time, eligible_for_retry, metadata)
 * - `event.data`: Include full event with payload data
 * - `response_data`: Include response body and headers
 */
export type AdminListAttemptsInclude = string | Array<string>;

/**
 * Field to sort by.
 */
export const AdminListAttemptsOrderBy = {
  Time: "time",
} as const;
/**
 * Field to sort by.
 */
export type AdminListAttemptsOrderBy = ClosedEnum<
  typeof AdminListAttemptsOrderBy
>;

/**
 * Sort direction.
 */
export const AdminListAttemptsDir = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Sort direction.
 */
export type AdminListAttemptsDir = ClosedEnum<typeof AdminListAttemptsDir>;

export type AdminListAttemptsRequest = {
  /**
   * Filter attempts by tenant ID. If not provided, returns attempts from all tenants.
   */
  tenantId?: string | undefined;
  /**
   * Filter attempts by event ID.
   */
  eventId?: string | undefined;
  /**
   * Filter attempts by destination ID.
   */
  destinationId?: string | undefined;
  /**
   * Filter attempts by status.
   */
  status?: AdminListAttemptsStatus | undefined;
  /**
   * Filter attempts by event topic(s). Can be specified multiple times or comma-separated.
   */
  topic?: string | Array<string> | undefined;
  /**
   * Filter attempts by event time >= value (RFC3339 or YYYY-MM-DD format).
   */
  timeGte?: Date | undefined;
  /**
   * Filter attempts by event time <= value (RFC3339 or YYYY-MM-DD format).
   */
  timeLte?: Date | undefined;
  /**
   * Number of items per page (default 100, max 1000).
   */
  limit?: number | undefined;
  /**
   * Cursor for next page of results.
   */
  next?: string | undefined;
  /**
   * Cursor for previous page of results.
   */
  prev?: string | undefined;
  /**
   * Fields to include in the response. Can be specified multiple times or comma-separated.
   *
   * @remarks
   * - `event`: Include event summary (id, topic, time, eligible_for_retry, metadata)
   * - `event.data`: Include full event with payload data
   * - `response_data`: Include response body and headers
   */
  include?: string | Array<string> | undefined;
  /**
   * Field to sort by.
   */
  orderBy?: AdminListAttemptsOrderBy | undefined;
  /**
   * Sort direction.
   */
  dir?: AdminListAttemptsDir | undefined;
};

/** @internal */
export const AdminListAttemptsStatus$inboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsStatus
> = z.nativeEnum(AdminListAttemptsStatus);
/** @internal */
export const AdminListAttemptsStatus$outboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsStatus
> = AdminListAttemptsStatus$inboundSchema;

/** @internal */
export const AdminListAttemptsTopic$inboundSchema: z.ZodType<
  AdminListAttemptsTopic,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type AdminListAttemptsTopic$Outbound = string | Array<string>;

/** @internal */
export const AdminListAttemptsTopic$outboundSchema: z.ZodType<
  AdminListAttemptsTopic$Outbound,
  z.ZodTypeDef,
  AdminListAttemptsTopic
> = z.union([z.string(), z.array(z.string())]);

export function adminListAttemptsTopicToJSON(
  adminListAttemptsTopic: AdminListAttemptsTopic,
): string {
  return JSON.stringify(
    AdminListAttemptsTopic$outboundSchema.parse(adminListAttemptsTopic),
  );
}
export function adminListAttemptsTopicFromJSON(
  jsonString: string,
): SafeParseResult<AdminListAttemptsTopic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdminListAttemptsTopic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdminListAttemptsTopic' from JSON`,
  );
}

/** @internal */
export const AdminListAttemptsInclude$inboundSchema: z.ZodType<
  AdminListAttemptsInclude,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type AdminListAttemptsInclude$Outbound = string | Array<string>;

/** @internal */
export const AdminListAttemptsInclude$outboundSchema: z.ZodType<
  AdminListAttemptsInclude$Outbound,
  z.ZodTypeDef,
  AdminListAttemptsInclude
> = z.union([z.string(), z.array(z.string())]);

export function adminListAttemptsIncludeToJSON(
  adminListAttemptsInclude: AdminListAttemptsInclude,
): string {
  return JSON.stringify(
    AdminListAttemptsInclude$outboundSchema.parse(adminListAttemptsInclude),
  );
}
export function adminListAttemptsIncludeFromJSON(
  jsonString: string,
): SafeParseResult<AdminListAttemptsInclude, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdminListAttemptsInclude$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdminListAttemptsInclude' from JSON`,
  );
}

/** @internal */
export const AdminListAttemptsOrderBy$inboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsOrderBy
> = z.nativeEnum(AdminListAttemptsOrderBy);
/** @internal */
export const AdminListAttemptsOrderBy$outboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsOrderBy
> = AdminListAttemptsOrderBy$inboundSchema;

/** @internal */
export const AdminListAttemptsDir$inboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsDir
> = z.nativeEnum(AdminListAttemptsDir);
/** @internal */
export const AdminListAttemptsDir$outboundSchema: z.ZodNativeEnum<
  typeof AdminListAttemptsDir
> = AdminListAttemptsDir$inboundSchema;

/** @internal */
export const AdminListAttemptsRequest$inboundSchema: z.ZodType<
  AdminListAttemptsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tenant_id: z.string().optional(),
  event_id: z.string().optional(),
  destination_id: z.string().optional(),
  status: AdminListAttemptsStatus$inboundSchema.optional(),
  topic: z.union([z.string(), z.array(z.string())]).optional(),
  "time[gte]": z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  "time[lte]": z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  limit: z.number().int().default(100),
  next: z.string().optional(),
  prev: z.string().optional(),
  include: z.union([z.string(), z.array(z.string())]).optional(),
  order_by: AdminListAttemptsOrderBy$inboundSchema.default("time"),
  dir: AdminListAttemptsDir$inboundSchema.default("desc"),
}).transform((v) => {
  return remap$(v, {
    "tenant_id": "tenantId",
    "event_id": "eventId",
    "destination_id": "destinationId",
    "time[gte]": "timeGte",
    "time[lte]": "timeLte",
    "order_by": "orderBy",
  });
});
/** @internal */
export type AdminListAttemptsRequest$Outbound = {
  tenant_id?: string | undefined;
  event_id?: string | undefined;
  destination_id?: string | undefined;
  status?: string | undefined;
  topic?: string | Array<string> | undefined;
  "time[gte]"?: string | undefined;
  "time[lte]"?: string | undefined;
  limit: number;
  next?: string | undefined;
  prev?: string | undefined;
  include?: string | Array<string> | undefined;
  order_by: string;
  dir: string;
};

/** @internal */
export const AdminListAttemptsRequest$outboundSchema: z.ZodType<
  AdminListAttemptsRequest$Outbound,
  z.ZodTypeDef,
  AdminListAttemptsRequest
> = z.object({
  tenantId: z.string().optional(),
  eventId: z.string().optional(),
  destinationId: z.string().optional(),
  status: AdminListAttemptsStatus$outboundSchema.optional(),
  topic: z.union([z.string(), z.array(z.string())]).optional(),
  timeGte: z.date().transform(v => v.toISOString()).optional(),
  timeLte: z.date().transform(v => v.toISOString()).optional(),
  limit: z.number().int().default(100),
  next: z.string().optional(),
  prev: z.string().optional(),
  include: z.union([z.string(), z.array(z.string())]).optional(),
  orderBy: AdminListAttemptsOrderBy$outboundSchema.default("time"),
  dir: AdminListAttemptsDir$outboundSchema.default("desc"),
}).transform((v) => {
  return remap$(v, {
    tenantId: "tenant_id",
    eventId: "event_id",
    destinationId: "destination_id",
    timeGte: "time[gte]",
    timeLte: "time[lte]",
    orderBy: "order_by",
  });
});

export function adminListAttemptsRequestToJSON(
  adminListAttemptsRequest: AdminListAttemptsRequest,
): string {
  return JSON.stringify(
    AdminListAttemptsRequest$outboundSchema.parse(adminListAttemptsRequest),
  );
}
export function adminListAttemptsRequestFromJSON(
  jsonString: string,
): SafeParseResult<AdminListAttemptsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdminListAttemptsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdminListAttemptsRequest' from JSON`,
  );
}
