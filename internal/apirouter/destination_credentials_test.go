package apirouter_test

import (
	"encoding/json"
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/hookdeck/outpost/internal/destregistry"
	destregistrydefault "github.com/hookdeck/outpost/internal/destregistry/providers"
	"github.com/hookdeck/outpost/internal/util/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// webhookStandardRegistry creates a registry with the real webhook standard
// provider registered as "webhook". This is needed because testutil.Registry
// uses the default (non-standard) webhook provider.
func webhookStandardRegistry(t *testing.T) destregistry.Registry {
	t.Helper()
	logger := testutil.CreateTestLogger(t)
	reg := destregistry.NewRegistry(&destregistry.Config{}, logger)
	err := destregistrydefault.RegisterDefault(reg, destregistrydefault.RegisterDefaultDestinationOptions{
		Webhook: &destregistrydefault.DestWebhookConfig{
			Mode: "standard",
		},
	})
	require.NoError(t, err)
	return reg
}

func TestDestinationCredentials_SecretAutoGeneratedOnCreate(t *testing.T) {
	h := newAPITest(t, withDestRegistry(webhookStandardRegistry(t)))
	h.tenantStore.UpsertTenant(t.Context(), tf.Any(tf.WithID("t1")))

	// Create destination without specifying a secret
	req := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
		"type":   "webhook",
		"topics": []string{"user.created"},
		"config": map[string]string{"url": "https://example.com/hook"},
	})
	resp := h.do(h.withAPIKey(req))
	require.Equal(t, http.StatusCreated, resp.Code)

	var dest destregistry.DestinationDisplay
	require.NoError(t, json.Unmarshal(resp.Body.Bytes(), &dest))

	assert.NotEmpty(t, dest.Credentials["secret"], "secret should be auto-generated")
	assert.True(t, strings.HasPrefix(dest.Credentials["secret"], "whsec_"),
		"auto-generated secret should have whsec_ prefix")
}

func TestDestinationCredentials_SecretRotationViaAPI(t *testing.T) {
	h := newAPITest(t, withDestRegistry(webhookStandardRegistry(t)))
	h.tenantStore.UpsertTenant(t.Context(), tf.Any(tf.WithID("t1")))

	// Create destination (secret auto-generated)
	createReq := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
		"id":     "d1",
		"type":   "webhook",
		"topics": []string{"user.created"},
		"config": map[string]string{"url": "https://example.com/hook"},
	})
	createResp := h.do(h.withAPIKey(createReq))
	require.Equal(t, http.StatusCreated, createResp.Code)

	var created destregistry.DestinationDisplay
	require.NoError(t, json.Unmarshal(createResp.Body.Bytes(), &created))
	initialSecret := created.Credentials["secret"]
	require.NotEmpty(t, initialSecret)
	assert.Empty(t, created.Credentials["previous_secret"])
	assert.Empty(t, created.Credentials["previous_secret_invalid_at"])

	// Rotate secret
	rotateReq := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
		"credentials": map[string]any{
			"rotate_secret": true,
		},
	})
	rotateResp := h.do(h.withAPIKey(rotateReq))
	require.Equal(t, http.StatusOK, rotateResp.Code)

	var rotated destregistry.DestinationDisplay
	require.NoError(t, json.Unmarshal(rotateResp.Body.Bytes(), &rotated))

	assert.NotEmpty(t, rotated.Credentials["secret"])
	assert.NotEqual(t, initialSecret, rotated.Credentials["secret"], "secret should have changed")
	assert.Equal(t, initialSecret, rotated.Credentials["previous_secret"],
		"previous_secret should be the old secret")
	assert.NotEmpty(t, rotated.Credentials["previous_secret_invalid_at"],
		"previous_secret_invalid_at should be set")
}

func TestDestinationCredentials_TenantCannotSetCustomSecret(t *testing.T) {
	h := newAPITest(t, withDestRegistry(webhookStandardRegistry(t)))
	h.tenantStore.UpsertTenant(t.Context(), tf.Any(tf.WithID("t1")))

	t.Run("create with secret via JWT returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
			"type":   "webhook",
			"topics": []string{"user.created"},
			"config": map[string]string{"url": "https://example.com/hook"},
			"credentials": map[string]any{
				"secret": "any-secret",
			},
		})
		resp := h.do(h.withJWT(req, "t1"))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	// Create destination without secret via JWT (should succeed)
	createReq := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
		"id":     "d1",
		"type":   "webhook",
		"topics": []string{"user.created"},
		"config": map[string]string{"url": "https://example.com/hook"},
	})
	createResp := h.do(h.withJWT(createReq, "t1"))
	require.Equal(t, http.StatusCreated, createResp.Code)

	t.Run("patch with secret via JWT returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"secret": "new-secret",
			},
		})
		resp := h.do(h.withJWT(req, "t1"))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("patch with previous_secret via JWT returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"previous_secret": "another-secret",
			},
		})
		resp := h.do(h.withJWT(req, "t1"))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("patch with previous_secret_invalid_at via JWT returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"previous_secret_invalid_at": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
			},
		})
		resp := h.do(h.withJWT(req, "t1"))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("patch with rotate_secret via JWT succeeds", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"rotate_secret": true,
			},
		})
		resp := h.do(h.withJWT(req, "t1"))

		assert.Equal(t, http.StatusOK, resp.Code)
	})
}

func TestDestinationCredentials_AdminCanSetCustomSecret(t *testing.T) {
	h := newAPITest(t, withDestRegistry(webhookStandardRegistry(t)))
	h.tenantStore.UpsertTenant(t.Context(), tf.Any(tf.WithID("t1")))

	secret := "whsec_dGVzdHNlY3JldDEyMzQ1Njc4OTBhYmNkZWY="
	newSecret := "whsec_dGVzdHNlY3JldDA5ODc2NTQzMjF6eXh3dnU="

	// Create destination with explicit secret
	createReq := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
		"id":     "d1",
		"type":   "webhook",
		"topics": []string{"user.created"},
		"config": map[string]string{"url": "https://example.com/hook"},
		"credentials": map[string]any{
			"secret": secret,
		},
	})
	createResp := h.do(h.withAPIKey(createReq))
	require.Equal(t, http.StatusCreated, createResp.Code)

	var created destregistry.DestinationDisplay
	require.NoError(t, json.Unmarshal(createResp.Body.Bytes(), &created))
	assert.Equal(t, secret, created.Credentials["secret"])

	t.Run("patch with new secret directly", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"secret": newSecret,
			},
		})
		resp := h.do(h.withAPIKey(req))
		require.Equal(t, http.StatusOK, resp.Code)

		var dest destregistry.DestinationDisplay
		require.NoError(t, json.Unmarshal(resp.Body.Bytes(), &dest))
		assert.Equal(t, newSecret, dest.Credentials["secret"])
	})

	t.Run("set previous_secret and previous_secret_invalid_at", func(t *testing.T) {
		gracePeriod := time.Now().Add(24 * time.Hour).Format(time.RFC3339)
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"secret":                     newSecret,
				"previous_secret":            secret,
				"previous_secret_invalid_at": gracePeriod,
			},
		})
		resp := h.do(h.withAPIKey(req))
		require.Equal(t, http.StatusOK, resp.Code)

		var dest destregistry.DestinationDisplay
		require.NoError(t, json.Unmarshal(resp.Body.Bytes(), &dest))
		assert.Equal(t, secret, dest.Credentials["previous_secret"])
		assert.NotEmpty(t, dest.Credentials["previous_secret_invalid_at"])
	})

	t.Run("empty secret returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"secret":                     "",
				"previous_secret":            secret,
				"previous_secret_invalid_at": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
			},
		})
		resp := h.do(h.withAPIKey(req))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("invalid date format returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"secret":                     newSecret,
				"previous_secret":            secret,
				"previous_secret_invalid_at": "invalid-date",
			},
		})
		resp := h.do(h.withAPIKey(req))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("rotate_secret on create returns 422", func(t *testing.T) {
		req := h.jsonReq(http.MethodPost, "/api/v1/tenants/t1/destinations", map[string]any{
			"id":     "d1-rotate",
			"type":   "webhook",
			"topics": []string{"user.created"},
			"config": map[string]string{"url": "https://example.com/hook"},
			"credentials": map[string]any{
				"rotate_secret": true,
			},
		})
		resp := h.do(h.withAPIKey(req))

		assert.Equal(t, http.StatusUnprocessableEntity, resp.Code)
	})

	t.Run("rotate secret as admin", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"rotate_secret": true,
			},
		})
		resp := h.do(h.withAPIKey(req))
		require.Equal(t, http.StatusOK, resp.Code)

		var dest destregistry.DestinationDisplay
		require.NoError(t, json.Unmarshal(resp.Body.Bytes(), &dest))
		assert.NotEqual(t, newSecret, dest.Credentials["secret"],
			"secret should have changed after rotation")
		assert.NotEmpty(t, dest.Credentials["previous_secret"])
		assert.NotEmpty(t, dest.Credentials["previous_secret_invalid_at"])
	})

	t.Run("admin unset previous_secret", func(t *testing.T) {
		req := h.jsonReq(http.MethodPatch, "/api/v1/tenants/t1/destinations/d1", map[string]any{
			"credentials": map[string]any{
				"previous_secret":            "",
				"previous_secret_invalid_at": "",
			},
		})
		resp := h.do(h.withAPIKey(req))
		require.Equal(t, http.StatusOK, resp.Code)

		var dest destregistry.DestinationDisplay
		require.NoError(t, json.Unmarshal(resp.Body.Bytes(), &dest))
		assert.NotEmpty(t, dest.Credentials["secret"], "secret should still exist")
		assert.Empty(t, dest.Credentials["previous_secret"],
			"previous_secret should be cleared")
		assert.Empty(t, dest.Credentials["previous_secret_invalid_at"],
			"previous_secret_invalid_at should be cleared")
	})
}
