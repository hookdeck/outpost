package e2e_test

import (
	"net/http"
	"time"
)

func (s *basicSuite) TestWebhookSignatures_RotatedSecretAcceptedDuringGracePeriod() {
	tenant := s.createTenant()
	secret := testSecret
	newSecret := testSecretAlt
	dest := s.createWebhookDestination(tenant.ID, "*", withSecret(secret))

	// Rotate secret on mock server: mock now verifies with new secret + previous secret
	dest.SetCredentials(s, map[string]string{
		"secret":                     newSecret,
		"previous_secret":            secret,
		"previous_secret_invalid_at": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
	})

	// Publish — outpost still signs with original secret, mock's previous_secret should match
	s.publish(tenant.ID, "user.created", map[string]any{
		"event_id": "rotated_test",
	})

	events := s.waitForNewMockServerEvents(dest.mockID, 1)
	s.Require().Len(events, 1)
	s.True(events[0].Verified, "signature should be verified via previous_secret during grace period")
}

func (s *basicSuite) TestWebhookSignatures_WrongSecretFailsVerification() {
	tenant := s.createTenant()
	secret := testSecret
	dest := s.createWebhookDestination(tenant.ID, "*", withSecret(secret))

	// Set wrong secret on mock server
	dest.SetSecret(s, "wrong-secret")

	s.publish(tenant.ID, "user.created", map[string]any{
		"event_id": "wrong_secret_test",
	})

	events := s.waitForNewMockServerEvents(dest.mockID, 1)
	s.Require().Len(events, 1)
	s.True(events[0].Success, "delivery should still succeed")
	s.False(events[0].Verified, "signature should NOT be verified with wrong secret")
}

func (s *basicSuite) TestWebhookSignatures_SecretAutoGeneratedOnCreate() {
	tenant := s.createTenant()
	dest := s.createWebhookDestination(tenant.ID, "*") // No secret specified

	got := s.getDestination(tenant.ID, dest.ID)
	s.Require().NotEmpty(got.Credentials["secret"], "secret should be auto-generated")
	s.Require().GreaterOrEqual(len(got.Credentials["secret"]), 32, "auto-generated secret should be at least 32 chars")
}

func (s *basicSuite) TestWebhookSignatures_SecretRotationViaAPI() {
	tenant := s.createTenant()
	dest := s.createWebhookDestination(tenant.ID, "*") // Auto-generated secret

	initial := s.getDestination(tenant.ID, dest.ID)
	initialSecret := initial.Credentials["secret"]
	s.Require().NotEmpty(initialSecret)
	s.Require().Empty(initial.Credentials["previous_secret"])
	s.Require().Empty(initial.Credentials["previous_secret_invalid_at"])

	// Rotate secret
	s.updateDestination(tenant.ID, dest.ID, map[string]any{
		"credentials": map[string]any{
			"rotate_secret": true,
		},
	})

	// Verify rotation
	rotated := s.getDestination(tenant.ID, dest.ID)
	s.NotEmpty(rotated.Credentials["secret"])
	s.NotEqual(initialSecret, rotated.Credentials["secret"], "secret should have changed")
	s.Equal(initialSecret, rotated.Credentials["previous_secret"], "previous_secret should be the old secret")
	s.NotEmpty(rotated.Credentials["previous_secret_invalid_at"], "previous_secret_invalid_at should be set")
}

func (s *basicSuite) TestWebhookSignatures_TenantCannotSetCustomSecret() {
	tenant := s.createTenant()
	token := s.jwtFor(tenant.ID)
	destID := "dest_tenant_secret_test"

	// Attempt to create destination with secret via JWT → 422
	var errResp map[string]any
	status := s.doJSONWithToken(http.MethodPost, s.apiURL("/tenants/"+tenant.ID+"/destinations"), token, map[string]any{
		"id":     destID,
		"type":   "webhook",
		"topics": "*",
		"config": map[string]any{
			"url": s.mockServerURL() + "/webhook/" + destID,
		},
		"credentials": map[string]any{
			"secret": "any-secret",
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)
	s.Equal("validation error", errResp["message"])

	// Create destination without secret via JWT → 201
	var createResp map[string]any
	status = s.doJSONWithToken(http.MethodPost, s.apiURL("/tenants/"+tenant.ID+"/destinations"), token, map[string]any{
		"id":     destID,
		"type":   "webhook",
		"topics": "*",
		"config": map[string]any{
			"url": s.mockServerURL() + "/webhook/" + destID,
		},
	}, &createResp)
	s.Require().Equal(http.StatusCreated, status)

	// PATCH with secret via JWT → 422
	status = s.doJSONWithToken(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+destID), token, map[string]any{
		"credentials": map[string]any{
			"secret": "new-secret",
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// PATCH with previous_secret via JWT → 422
	status = s.doJSONWithToken(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+destID), token, map[string]any{
		"credentials": map[string]any{
			"previous_secret": "another-secret",
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// PATCH with previous_secret_invalid_at via JWT → 422
	status = s.doJSONWithToken(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+destID), token, map[string]any{
		"credentials": map[string]any{
			"previous_secret_invalid_at": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// PATCH with rotate_secret:true via JWT → 200 (allowed)
	var rotateResp map[string]any
	status = s.doJSONWithToken(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+destID), token, map[string]any{
		"credentials": map[string]any{
			"rotate_secret": true,
		},
	}, &rotateResp)
	s.Equal(http.StatusOK, status)
}

func (s *basicSuite) TestWebhookSignatures_AdminCanSetCustomSecret() {
	tenant := s.createTenant()
	secret := testSecret
	newSecret := testSecretAlt

	// Create destination with explicit secret
	dest := s.createWebhookDestination(tenant.ID, "*", withSecret(secret))

	// Verify custom secret was set
	got := s.getDestination(tenant.ID, dest.ID)
	s.Equal(secret, got.Credentials["secret"])

	// PATCH with new secret directly
	s.updateDestination(tenant.ID, dest.ID, map[string]any{
		"credentials": map[string]any{
			"secret": newSecret,
		},
	})
	got = s.getDestination(tenant.ID, dest.ID)
	s.Equal(newSecret, got.Credentials["secret"])

	// Set previous_secret + previous_secret_invalid_at
	gracePeriod := time.Now().Add(24 * time.Hour).Format(time.RFC3339)
	s.updateDestination(tenant.ID, dest.ID, map[string]any{
		"credentials": map[string]any{
			"secret":                     newSecret,
			"previous_secret":            secret,
			"previous_secret_invalid_at": gracePeriod,
		},
	})
	got = s.getDestination(tenant.ID, dest.ID)
	s.Equal(secret, got.Credentials["previous_secret"])
	s.NotEmpty(got.Credentials["previous_secret_invalid_at"])

	// Validation: empty secret → 422
	var errResp map[string]any
	status := s.doJSON(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+dest.ID), map[string]any{
		"credentials": map[string]any{
			"secret":                     "",
			"previous_secret":            secret,
			"previous_secret_invalid_at": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// Validation: invalid date format → 422
	status = s.doJSON(http.MethodPatch, s.apiURL("/tenants/"+tenant.ID+"/destinations/"+dest.ID), map[string]any{
		"credentials": map[string]any{
			"secret":                     newSecret,
			"previous_secret":            secret,
			"previous_secret_invalid_at": "invalid-date",
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// Validation: rotate_secret on create → 422
	status = s.doJSON(http.MethodPost, s.apiURL("/tenants/"+tenant.ID+"/destinations"), map[string]any{
		"id":     dest.ID + "-rotate",
		"type":   "webhook",
		"topics": "*",
		"config": map[string]any{
			"url": s.mockServerURL() + "/webhook/" + dest.ID,
		},
		"credentials": map[string]any{
			"rotate_secret": true,
		},
	}, &errResp)
	s.Equal(http.StatusUnprocessableEntity, status)

	// Rotate secret as admin
	s.updateDestination(tenant.ID, dest.ID, map[string]any{
		"credentials": map[string]any{
			"rotate_secret": true,
		},
	})

	// Verify rotation worked
	got = s.getDestination(tenant.ID, dest.ID)
	s.NotEqual(newSecret, got.Credentials["secret"], "secret should have changed after rotation")
	s.NotEmpty(got.Credentials["previous_secret"])
	s.NotEmpty(got.Credentials["previous_secret_invalid_at"])

	// Admin unset previous_secret
	s.updateDestination(tenant.ID, dest.ID, map[string]any{
		"credentials": map[string]any{
			"previous_secret":            "",
			"previous_secret_invalid_at": "",
		},
	})

	got = s.getDestination(tenant.ID, dest.ID)
	s.NotEmpty(got.Credentials["secret"], "secret should still exist")
	s.Empty(got.Credentials["previous_secret"], "previous_secret should be cleared")
	s.Empty(got.Credentials["previous_secret_invalid_at"], "previous_secret_invalid_at should be cleared")
}
